;; exclusive or
(define (xor first second)
  (if first
      (not second)
      second))


;; using nondeterministic programs
(define (liars-puzzle)
  (let ((betty (amb 1 2 3 4 5))
	(ethel (amb 1 2 3 4 5))
	(joan (amb 1 2 3 4 5))
	(kitty (amb 1 2 3 4 5))
	(mary (amb 1 2 3 4 5)))
    (require (xor (= kitty 2) (= betty 3)))
    (require (xor (= ethel 1) (= joan 2)))
    (require (xor (= joan 3) (= ethel 5)))
    (require (xor (= kitty 2) (= mary 4)))
    (require (xor (= mary 4) (= betty 1)))
    (list (list 'betty betty)
	  (list 'ethel ethel)
	  (list 'joan joan)
	  (list 'kitty kitty)
	  (list 'mary mary))))



;; not using nondeterministic programs
;; from ex 41
(define (flatmap proc seq)
  (if (null? seq)
      '()
      (append (car (map proc seq))
		(flatmap proc (cdr seq)))))
(define (add-atom elt atom n)
  (cond ((> n (length elt))
	 (append elt (list n)))
	((= n 0) (cons atom elt))
	(else (cons (car elt)
		    (add-atom (cdr elt) atom (- n 1))))))
(define (add-atom-lists elt atom)
  (define (iter num)
    (if (< num 0)
	'()
	(cons (add-atom elt atom num)
	      (iter (- num 1)))))
  (iter (length elt)))
(define (make-lists n)
  (define (iter num)
    (if (= num 0)
	(list '())
	(flatmap (lambda (elt) (add-atom-lists elt num))
		 (iter (- num 1)))))
  (iter n))


(define (liars-puzzle2)
  (define (check elt)
    (let ((betty (car elt))
	(ethel (cadr elt))
	(joan (caddr elt))
	(kitty (cadddr elt))
	(mary (cadddr (cdr elt))))
    (if (and (xor (= kitty 2) (= betty 3))
	     (xor (= ethel 1) (= joan 2))
	     (xor (= joan 3) (= ethel 5))
	     (xor (= kitty 2) (= mary 4))
	     (xor (= mary 4) (= betty 1)))
	(list (list 'betty betty)
	      (list 'ethel ethel)
	      (list 'joan joan)
	      (list 'kitty kitty)
	      (list 'mary mary))
	'())))
  (flatmap check (make-lists 5)))

(liars-puzzle2)
;; => ((betty 3) (ethel 5) (joan 2) (kitty 1) (mary 4))
